---
export interface Props {
  defaultFilter?: string;
  defaultSort?: string;
}
const { defaultFilter = "all", defaultSort = "newest" } = Astro.props;
---

<section class="controls">
  <div class="filters">
    <div class="group">
      <label for="filter">表示:</label>
      <select id="filter" class="select">
        <option value="all" selected={defaultFilter === "all"}>すべて</option>
        <option value="unread" selected={defaultFilter === "unread"}
          >未読のみ</option
        >
        <option value="favorite" selected={defaultFilter === "favorite"}
          >お気に入りのみ</option
        >
      </select>
    </div>
    <div class="group">
      <label for="sort">並び替え:</label>
      <select id="sort" class="select">
        <option value="newest" selected={defaultSort === "newest"}
          >新着順</option
        >
        <option value="oldest" selected={defaultSort === "oldest"}
          >古い順</option
        >
      </select>
    </div>
  </div>

  <div class="search">
    <input
      type="text"
      id="search-articles"
      placeholder="記事を検索..."
      class="input"
    />
    <button id="search-btn" class="btn">検索</button>
  </div>
</section>
<style>
  .controls {
    margin-block-end: var(--spacing-xl);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--spacing-md);

    @media (max-width: 768px) {
      flex-direction: column;
      align-items: stretch;
    }
  }

  .filters {
    display: flex;
    gap: var(--spacing-lg);
    align-items: center;

    @media (max-width: 768px) {
      flex-direction: column;
      align-items: flex-start;
      gap: var(--spacing-sm);
    }
  }

  .group {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
  }

  .select,
  .input {
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--spacing-xs);
    border: 1px solid var(--color-border);
    background: var(--color-surface);
    color: var(--color-text);
    font-size: var(--font-size-sm);
  }

  .search {
    display: flex;
    gap: var(--spacing-xs);

    .input {
      min-width: 200px;

      @media (max-width: 768px) {
        flex-grow: 1;
        min-width: unset;
      }
    }

    @media (max-width: 768px) {
      width: 100%;
    }
  }

  .btn {
    background: var(--color-primary);
    color: var(--color-text-on-primary);
    border: none;
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--spacing-xs);
    cursor: pointer;
    font-size: var(--font-size-sm);
    transition: background-color 0.2s ease;

    &:hover {
      background: var(--color-primary-hover);
    }

    &:focus-visible {
      outline: 3px solid var(--color-primary-light);
      outline-offset: 2px;
    }
  }
</style>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    // 型定義
    type FilterValue = "all" | "unread" | "favorite";
    type SortValue = "newest" | "oldest";

    interface ArticleElement extends HTMLElement {
      style: CSSStyleDeclaration;
      querySelector<E extends Element = Element>(selectors: string): E | null;
    }

    // DOM要素の取得と型付け
    const filterSelect = document.getElementById(
      "filter",
    ) as HTMLSelectElement | null;
    const sortSelect = document.getElementById(
      "sort",
    ) as HTMLSelectElement | null;
    const searchInput = document.getElementById(
      "search-articles",
    ) as HTMLInputElement | null;
    const searchBtn = document.getElementById(
      "search-btn",
    ) as HTMLButtonElement | null;
    const articlesContainer =
      document.querySelector<HTMLElement>(".articles-grid");

    // 絞り込み関数
    const filterArticles = (): void => {
      const filterValue: FilterValue =
        (filterSelect?.value as FilterValue) || "all";
      const searchValue: string =
        searchInput?.value?.toLowerCase().trim() || "";

      // カスタムデータ属性を使用して、状態をドキュメントに保存
      document.documentElement.dataset.articleFilter = filterValue;
      document.documentElement.dataset.articleSearch = searchValue
        ? "true"
        : "false";

      if (!articlesContainer) return;

      // 全ての記事カードを取得
      const articles: NodeListOf<ArticleElement> =
        articlesContainer.querySelectorAll(".article-card");

      articles.forEach((article) => {
        const status: string | null = article.getAttribute("data-status");
        const title: string = article.getAttribute("data-title") || "";
        const summary: string = article.getAttribute("data-summary") || "";

        let visible = true;

        // フィルタリング条件の適用
        if (filterValue === "unread" && status !== "unread") {
          visible = false;
        }

        // 検索条件の適用
        if (
          visible &&
          searchValue &&
          !(title.includes(searchValue) || summary.includes(searchValue))
        ) {
          visible = false;
        }

        // CSS表示/非表示を適用
        article.style.display = visible ? "" : "none";
      });
    };

    // ソート関数
    const sortArticles = (): void => {
      const sortValue: SortValue = (sortSelect?.value as SortValue) || "newest";

      if (!articlesContainer) return;

      const articles: ArticleElement[] = Array.from(
        articlesContainer.querySelectorAll<ArticleElement>(".article-card"),
      );

      articles.sort((a, b) => {
        // 日付の取得（時間要素のdatetimeを使用）
        const timeA = a.querySelector<HTMLTimeElement>("time");
        const timeB = b.querySelector<HTMLTimeElement>("time");
        const dateA = new Date(timeA?.getAttribute("datetime") || "");
        const dateB = new Date(timeB?.getAttribute("datetime") || "");

        // ソート順（新着順なら降順、古い順なら昇順）
        return sortValue === "newest"
          ? dateB.getTime() - dateA.getTime()
          : dateA.getTime() - dateB.getTime();
      });

      // DOMの並び順を更新
      articles.forEach((article) => articlesContainer.appendChild(article));
    };

    // イベントリスナーの設定
    filterSelect?.addEventListener("change", filterArticles);
    sortSelect?.addEventListener("change", sortArticles);

    searchBtn?.addEventListener("click", filterArticles);
    searchInput?.addEventListener("keyup", (e: KeyboardEvent) => {
      if (e.key === "Enter") {
        filterArticles();
      }
    });

    // 初期フィルタリング実行
    filterArticles();

    // 初期ソート実行
    sortArticles();
  });
</script>
