ありがとうございます。最新のCSS技術を活用した、経験者向けの包括的なコーディングガイドを作成します。

- **対象読者**: AstroやNueのようなJavaScriptに依存しない開発者向け。
- **技術スタック**: 最新のPure CSS技術のみ。
- **トピック**: ネスト、疑似クラス・疑似要素、ユーティリティファースト vs セマンティックCSS、レスポンシブデザイン、カスタムプロパティなど、モダンCSSの全領域をカバー。
- **具体的なコード例**: 実践的なサンプルを適宜挿入。
- **出力形式**: Markdown (`.md`) 形式で出力。

ドキュメントが完成したらお知らせします。しばらくお待ちください。

# 最新Pure CSSテクニック 実践ガイド

**対象読者:** 本ガイドは、AstroやNueのような**JavaScript非依存**のフロントエンド開発に携わる経験者を念頭に、2025年時点の最新CSS仕様とモダンなベストプラクティスを包括的にまとめたものです。純粋なCSSのみを使った開発手法にフォーカスし、**即戦力となるテクニック**を具体例とともに紹介します。

**カバーするトピック:**

- CSSネスト（`@nest` 他）
- 擬似クラス・擬似要素（`:has()`, `:where()`, `:is()` 他）
- コンポーネントベースの設計とスコープ管理（`:scope`, `@layer`）
- ユーティリティファースト vs セマンティックCSS
- レスポンシブデザイン（Container Queries, `min()`, `max()`, `clamp()`）
- アクセシビリティ考慮事項
- CSS変数・カスタムプロパティ（`--*`変数, `@property`）
- アニメーション・トランジション（`@keyframes`, View/Scroll Timeline）
- 最新グリッドレイアウト（`subgrid`, `grid-template-areas`）
- 最新フレックスボックス（`gap`, `align-content`, `justify-content`）
- カラー・タイポグラフィ（`color-mix()`, `@font-face`, `font-display`）
- ブラウザサポートとフォールバック（Feature Queries 等）

各セクションで概念説明とコード例を示し、必要に応じて参考資料を挙げます。**目次:**

1. [CSSネスト – ネイティブなネスト機能](#cssネスト--ネイティブなネスト機能)
2. [高度な擬似クラス・擬似要素の活用](#高度な擬似クラス・擬似要素の活用)
3. [コンポーネント設計とスタイルのスコープ管理](#コンポーネント設計とスタイルのスコープ管理)
4. [ユーティリティファースト vs セマンティックCSS](#ユーティリティファースト-vs-セマンティックcss)
5. [最新レスポンシブデザイン技法](#最新レスポンシブデザイン技法)
6. [アクセシビリティを高めるCSS設計](#アクセシビリティを高めるcss設計)
7. [CSS変数・カスタムプロパティ活用術](#css変数・カスタムプロパティ活用術)
8. [モダンなアニメーションとトランジション](#モダンなアニメーションとトランジション)
9. [進化したグリッドレイアウト](#進化したグリッドレイアウト)
10. [進化したフレックスボックス](#進化したフレックスボックス)
11. [最新カラー機能とタイポグラフィ戦略](#最新カラー機能とタイポグラフィ戦略)
12. [ブラウザサポートとフォールバック戦略](#ブラウザサポートとフォールバック戦略)

---

## CSSネスト – ネイティブなネスト機能

従来、Sassなどプリプロセッサで提供されていた**CSSネスト**機能が、ネイティブCSSでも使用可能になりつつあります。CSS Nesting Moduleにより、スタイルシートを**読みやすく、モジュール化しやすく**でき、セレクタの繰り返しを減らして**保守性向上とファイルサイズ削減**にも寄与します ([Using CSS nesting - CSS: Cascading Style Sheets | MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_nesting/Using_CSS_nesting#:~:text=The%20CSS%20nesting%20module%20allows,size%20can%20also%20be%20reduced))。ブラウザが直接ネスト構文を解釈する点がプリプロセッサとの違いで、特に`&`（親セレクタ参照）の**特殊な具体性**ルール（親セレクタリスト中で最大の具体性を引き継ぐ）など、ネイティブならではの仕様があります ([Using CSS nesting - CSS: Cascading Style Sheets | MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_nesting/Using_CSS_nesting#:~:text=CSS%20nesting%20is%20different%20from,in%20the%20associated%20selector%20list)) ([Using CSS nesting - CSS: Cascading Style Sheets | MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_nesting/Using_CSS_nesting#:~:text=a%20CSS%20preprocessor,in%20the%20associated%20selector%20list))。

### ネストの基本構文

CSSネストでは、親ルール内に子のスタイルルールを記述できます。例えば以下のように、親 `.card` 内に子要素 `.title` のスタイルをネスト可能です。

```css
/* 通常の（非ネスト）記法 */
.card {
  /* 親要素のスタイル */
}
.card .title {
  /* 子要素のスタイル */
}

/* ネスト記法を用いた場合 */
.card {
  /* 親要素のスタイル */
  .title {
    /* 子要素のスタイル */
  }
}
```

このように書くことで親子関係が明示され、関連スタイルを**一箇所にまとめて記述**できます。必要に応じて親セレクタ参照の`&`も使用可能です。例えば擬似クラスを付与する場合や、複合セレクタを結合する場合に`&`が有用です ([Using CSS nesting - CSS: Cascading Style Sheets | MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_nesting/Using_CSS_nesting#:~:text=There%20are%20certain%20instances%20where,can%20be%20necessary%20or%20helpful)):

```css
.button {
  /* ボタン標準スタイル */
  &:hover,
  &:focus {
    /* ホバーまたはフォーカス時 */
    background: var(--btn-hover-bg);
  }
}
```

上記では、`.button:hover, .button:focus`に対するスタイルをネスト内で表現しています（`&`は親の`.button`を指す）。このように**ネストと`&`を組み合わせる**ことで、コードの構造を視覚的に捉えやすくなります。

### 対応ブラウザと注意点

CSSネストは2023年頃から最新ブラウザで使えるようになりつつあります。ただし**一部古いブラウザでは未対応**の場合があるため、利用時は必要に応じてポリフィルやビルド時変換（PostCSSのnestingプラグイン等）でフォールバックすることも検討してください。なお、ネストが未対応のブラウザでは、その**ネストされたセレクタ全体が無効**になってしまう点に留意しましょう。例えば `parent { child { ... } }` というネストが不明な構文と見なされるブラウザでは、そのブロック内すべてのスタイルが適用されません。これを避けるための高度なテクニックとして、`:is()` や `:where()` を組み合わせてForgivingなセレクタリストを作る方法があります（詳細は後述の擬似クラスの節を参照）。

## 高度な擬似クラス・擬似要素の活用

CSS Selectors Level 4で導入・拡張された**擬似クラス**を活用することで、これまで困難だった要素の状態や関係性を簡潔にスタイル指定できます。中でも注目すべきものが`:has()`, `:is()`, `:where()`です。これらは**柔軟なセレクタ指定**や**特定条件下の親要素選択**など、強力な表現力を提供します。

- **`:has()` 擬似クラス** – **“親選択子”**とも呼ばれ、特定の子孫要素を持つ要素（親要素や先行兄弟要素）にスタイルを適用可能です。たとえば、`.card:has(img)` とすると「画像を含む `.card` 要素」にスタイルを当てられます。以下は`:has()`の例です。

  ```css
  /* 直後に<p>を持つ<h1>に下マージン0を適用 */
  h1:has(+ p) {
    margin-bottom: 0;
  }
  ```

  上記は`<h1>`の直後に`<p>`がある場合、その`<h1>`のマージンを下方向だけゼロにしています。このように`:has()`を使えば、**子要素の有無に応じて親のスタイルを変える**（例えば子を持つときだけ余白調整する等）ことができます。CSSだけで親要素を選択できるのは画期的で、従来JavaScriptに頼っていたケースもCSSのみで実現可能です。

  **特記事項:** `:has()`自体の**具体性**（specificity）は、引数内で最も高い具体性に合わせられます。また、`@supports`や`:is()`, `:where()`と組み合わせて書くことで、古いブラウザにおけるフォールバックも容易になります（古いブラウザは`:has()`を含むセレクタ全体を無視しますが、`:is()`/`:where()`の引数なら無視された部分だけ除外して解釈されるためです）。

- **`:is()` 擬似クラス** – セレクタリストをまとめ、**重複スタイルの記述を減らす**ために有効です。複数のセレクタに共通のスタイルを適用したい場合に、一つの`:is()`にまとめることでコード量を削減できます。例えば、`.btn:active, .btn.active, .btn[aria-pressed="true"]` という3つの条件を共通スタイルにしたい場合、`.btn:is(:active, .active, [aria-pressed="true"])` のように書けます。`:is()`の具体性は、引数内で**最も高い具体性**に揃えられる点に注意してください。これは従来のセレクタリストと同じですが、次の`:where()`との違いになります。

- **`:where()` 擬似クラス** – `:is()`と同様にセレクタリストを受け取りますが、**常に具体性0**として扱われます。つまり、`:where()`内のセレクタの具体性が**完全にリセット**されるのが特徴です。これにより、スタイル適用の順序制御をより柔軟にできます。たとえば、特定の要素群を低い優先度でデフォルトスタイル指定したいときに役立ちます（後述のCSSレイヤーとも併用可能）。さらに`:where()`や`:is()`は**Forgiving Selector**として働き、リスト内に未対応のセレクタ（例えば古ブラウザ未実装の擬似クラス）が含まれていても他の部分は有効になります。これを利用し、例えば`:is(.card, .legacy-card:has(img))`のように書けば、`:has`未対応ブラウザでも`.card`部分は適用される、といったフォールバックが可能です。

これら最新の擬似クラスにより、**HTML構造に沿った自然なスタイル指定**ができるようになりました。なお、`:focus-visible`（キーボード操作時のみフォーカスリング表示）など他の擬似クラスもアクセシビリティで重要ですが、それらは後のセクションで触れます。

## コンポーネント設計とスタイルのスコープ管理

モダンなフロントエンド開発では、UIをコンポーネント単位で設計し、そのスタイルを**漏れなく管理**することが求められます。CSS側でも、**特定の範囲内だけに適用されるスタイル**や**スタイルシート間の干渉を防ぐ仕組み**が整ってきました。この節では、スタイルのスコープ管理に役立つ`:scope`擬似クラスと、CSS Cascading Layers（レイヤー機能）の`@layer`について解説します。

- **`:scope` 擬似クラス** – あるDOM領域内での**基準要素**を指す擬似クラスです ([scope - CSS: Cascading Style Sheets - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/CSS/:scope#:~:text=scope%20,for%20selectors%20to%20match%20against))。通常、ブラウザのCSSセレクタはグローバルなHTMLツリー全体を対象にしますが、`:scope`を使うと**現在のコンテキストに限定**してセレクタをマッチさせることができます。例えば、あるコンポーネントのルート要素に`:scope`を指定し、その子孫要素をスタイリングすることで、**コンポーネント外へのスタイル漏れを防ぐ**ことができます。具体的には以下のような使い方です。

  ```html
  <div class="modal">
    <h2>タイトル</h2>
    <p>内容...</p>
  </div>
  ```

  ```css
  .modal:scope h2 {
    /* .modal内のh2に適用（他のh2には影響しない） */
    font-size: 1.5rem;
  }
  ```

  上記では、`.modal:scope h2`が`.modal`コンテナ内の`<h2>`だけを対象にします。`:scope`はJavaScriptのDOM API（`document.querySelector()`など）でも基準要素として使われますが、CSSセレクタ内でも限定用途に有用です。ただし、現状`:scope`は主に**スタイル指定時の補助**であり、実際にスコープを隔離するには後述の`@layer`等と組み合わせる必要があります。

- **`@layer` ディレクティブ（CSSカスケードレイヤー）** – 2022年に標準化された新機能で、スタイルシート内に**レイヤー（層）**の概念を導入します。これは、従来の**スタイル競合の解決（カスケード順序）**を開発者が明示的にコントロールできる仕組みです。複数のソースから当たるCSS（例えばリセットCSS、ベーススタイル、コンポーネントスタイル、ユーティリティ等）に**優先順位のグループ分け**を与えられます。

  **基本文法:** `@layer`には**ステートメント形式**と**ブロック形式**があります。簡単な例を示します。

  ```css
  /* レイヤーの宣言（優先度が低い順に列挙） */
  @layer reset, base, components, utilities;

  @layer reset {
    /* リセットCSS: 他のレイヤーより低優先 */
    * {
      margin: 0;
      padding: 0;
    }
  }
  @layer base {
    /* ベーススタイル: デフォルトのタグスタイルなど */
    body {
      font-family: sans-serif;
    }
    h1 {
      font-size: 2rem;
    }
  }
  @layer components {
    /* コンポーネントスタイル: 各UI部品の基本スタイル */
    .card {
      /* ... */
    }
    .modal {
      /* ... */
    }
  }
  @layer utilities {
    /* ユーティリティ: 便利クラスや上書き用 */
    .text-center {
      text-align: center;
    }
  }
  ```

  上記では、`reset`→`base`→`components`→`utilities`の順にレイヤーを定義し、それぞれのスタイルをその中に記述しています。**最初に宣言されたレイヤーが一番下位**となり、あとから宣言されたレイヤーほど優先されます。この例では `utilities` レイヤーのスタイルが他のレイヤーを**上書き可能**であり、逆に`reset`は全レイヤー中最下位となります。

  Cascade Layersを使うことで、例えば外部ライブラリのCSSを一つのレイヤーにまとめ、自分のアプリケーションスタイルを別レイヤーに置けば、**特定のレイヤー全体を丸ごと優先/逆転**させることもできます。また、レイヤー内では従来通り具体性やソース順に従ってカスケードします。

  **注意点:** レイヤーを使わない通常のCSS（無名レイヤー）は、デフォルトで**全てのレイヤーより後に適用**されます。したがって、`@layer`を導入する際は全スタイルを何らかのレイヤーに属せるか検討しましょう。無名スタイルがあると、それらが最強になってしまうためです。

このように、`:scope`で**コンポーネント内に閉じたセレクタ**を書き、`@layer`で**大局的なスタイル優先度**を設計することで、複雑なプロジェクトでもスタイルが衝突しにくくなり、メンテナンスしやすくなります。

## ユーティリティファースト vs セマンティックCSS

CSS設計手法として**「ユーティリティファースト」**と**「セマンティック（意味的）CSS」**というアプローチがあります。それぞれメリット・デメリットがありますが、最新のCSS環境でも依然として議論が続く重要トピックです。

- **セマンティックCSS**: HTMLには内容や役割を表す**意味的なクラス名**を付与し、CSS側でそのクラスにスタイルを当てる手法です。典型的には、クラス名は要素の目的や種類を表し（例: `.navbar`, `.card`, `.button-primary`など）、デザインの見た目については含めません。こうすることで、HTML（構造・内容）とCSS（見た目）を明確に分離し、例えば同一HTMLでもスタイルシートを差し替えれば全く異なるデザインに変更できる（CSS Zen Gardenの例など）という**関心の分離**が実現します。セマンティックCSSの利点は、HTMLを見ただけでその要素の意図が分かり、スタイルの再利用性も上がる点です。

  _例:_

  ```html
  <!-- 悪い例：ユーティリティクラスのみ -->
  <p class="text-center bold red">Hello</p>
  <!-- 良い例：意味的なクラス名 -->
  <p class="greeting">Hello</p>
  ```

  ```css
  .greeting {
    text-align: center;
    font-weight: bold;
    color: red;
  }
  ```

  上記では、後者の方がクラス名で内容の意味（挨拶文）を表しており、スタイルはCSSで定義しています。このようにセマンティックな命名により、**HTMLがスタイルから独立**し保守性が高まります。

- **ユーティリティファーストCSS**: 一方、ユーティリティファーストでは、**1プロパティ=1クラス**のような**小さな汎用クラス**を大量に用意し、HTML側で組み合わせてスタイルを適用します。例えば`.text-center`（中央寄せ）や`.mt-4`（マージン上4）等、Tailwind CSSに代表されるようなスタイルです。これにより、CSSファイル側に個々のコンポーネント用スタイルを書かなくても、HTMLのクラス指定だけで見た目を調整できます。利点は、デザインごとに新たなクラスを定義せず**既存のユーティリティを組み合わせて使い回せる**点や、逐一CSSを書かないので**開発スピードが上がる**点です。

  _例:_

  ```html
  <!-- ユーティリティクラスのみで構成 -->
  <p class="text-center fw-bold text-red">Hello</p>
  ```

  ```css
  .text-center {
    text-align: center;
  }
  .fw-bold {
    font-weight: bold;
  }
  .text-red {
    color: red;
  }
  ```

  このようにHTMLに直接「どう表示するか」の情報（中央寄せや赤色）が入るため、一見すると関心の分離に反するように思えます。しかしユーティリティ派の主張としては、**クラス名＝スタイル**と割り切ることで命名の悩みが減り、スタイル定義もDRY（Don't Repeat Yourself）になるという点があります。また、「HTMLに直接スタイルを書く」のではなく「CSSで定義済みのクラスをHTMLで付与する」だけなので、かろうじて分離は保たれているとも言えます。

**どちらを採用すべきか？**  
プロジェクトの性質によります。セマンティックCSSは**長期運用**や**デザイントレンド変更**に強く、チームでの意味共有がしやすいです。一方、ユーティリティファーストは**プロトタイピングや一貫したデザインシステム**に強く、大規模サイトでもTailwindのように厳密管理すれば保守可能です。混在も可能で、**基本はセマンティックにしつつ、一部頻出スタイルはユーティリティ化**するといったハイブリッドも一般的です。

最新CSSでは、カスタムプロパティによるデザイントークン管理や`@layer`によるユーティリティレイヤー分離など、**両アプローチの利点を取り入れる環境**が整っています。例えば、ユーティリティクラス群を専用のCascade Layerに置きつつ、コンポーネント固有スタイルは別レイヤーにすることで、容易にユーティリティ＞コンポーネントの優先度を制御できます。また、セマンティッククラス名でも冗長になりがちな部分は`:is()`でまとめる等、モダンCSSの力で効率化できます。

要するに、**「どちらが正解」というよりプロジェクトに応じ使い分ける」**というスタンスが2025年現在のベストプラクティスです。CSS自体の機能強化により、スタイル設計の自由度は増しています。

## 最新レスポンシブデザイン技法

レスポンシブ対応は今や標準ですが、近年**メディアクエリ**だけでなく**コンテナクエリ**など新たな手段が登場しました。あわせて、`min()`, `max()`, `clamp()`といったCSS関数により、より洗練された**流動レイアウト**や**流体タイポグラフィ**が可能になっています。このセクションでは、最新レスポンシブ技法を順に見ていきます。

### コンテナクエリ (`@container` ルール)

**コンテナクエリ (Container Queries)** は、従来のメディアクエリが**画面全体のビューポート**に基づいてスタイルを切り替えていたのに対し、**特定のコンテナ要素のサイズ**に基づいてスタイルを適用するものです。コンポーネントが配置される親のスペースに応じてデザインを変えることで、より柔軟なレスポンシブ設計が可能になります。例えば「カードコンポーネントがサイドバーに置かれ狭い場合は小さな余白にする、一方メイン領域で広く表示されるときは大きな余白にする」といった調整が容易です。

**使い方:** コンテナクエリを使うには、まず**クエリ対象のコンテナ要素**に対し`container-type`プロパティを指定して**「この要素をコンテナにする」**宣言をします。値は`size`（ブロック方向とインライン方向両方でクエリ対象）, `inline-size`（インライン軸方向のみ）, `normal`（コンテナとして機能しない）があります。一般的には水平方向のサイズに応じてレイアウト調整するケースが多いので、`container-type: inline-size`を指定することが多いです。

次に、CSSで`@container`ルールを記述します。書式は`@container (<条件>) { ... }`で、メディアクエリの`@media`に似ています。条件部では、そのコンテナの幅や高さなどを`(min-width: 500px)`のように指定します。以下に具体例を示します。

```html
<div class="post">
  <div class="card">
    <h2>Card Title</h2>
    <p>カードの内容テキスト。</p>
  </div>
</div>
```

```css
.post {
  container-type: inline-size; /* .post要素をコンテナに設定 */
}

/* デフォルトのカードタイトルスタイル */
.card h2 {
  font-size: 1em;
}

/* コンテナ(.post)が幅700px以上の場合に適用 */
@container (min-width: 700px) {
  .card h2 {
    font-size: 2em;
  }
}
```

上記では、`.post`要素をコンテナに指定し、そのコンテナ幅が`700px`以上なら内側の`.card h2`の文字サイズを2倍にしています。このように書くことで、`.card`コンポーネントは**配置先のコンテナ幅に応じて**タイトル文字サイズを変化させます。結果として、`.post`コンテナが狭ければ小さい文字、広ければ大きい文字になり、同じ`.card`を複数の場所で再利用しても各コンテナ内で最適なスタイルが適用されます。これはメディアクエリでは親要素ごとの条件分岐が難しかった点を解消する強力な機能です。

**コンテナの命名:** 複数のコンテナがある場合、それぞれに`container-name`で名前を付けて`@container <name> (条件)`と記述すれば、指定の名前を持つコンテナに対する条件だけを記述可能です。ただ多くの場合、近傍の親コンテナに対する無名クエリで事足ります。

**ブラウザ対応:** コンテナクエリは2023年にChrome・Safari・Firefoxすべてで対応し始め、現在はモダンブラウザ間でほぼ利用可能です。古い環境向けには無視されてもレイアウトが破綻しないよう、**基本デザインをまずCSSに記述し、拡張的に@container内でスタイルを上書きする**（プログレッシブエンハンスメント）構成にすると良いでしょう。

### `min()`, `max()`, `clamp()`による流動的デザイン

CSS Values Level 4で導入された数学関数`min()`, `max()`, `clamp()`は、要素サイズやフォントサイズを**条件付きで滑らかに変化させる**のに役立ちます。各関数の概要:

- **`min(a, b, ...)`**: 複数の値から**最小値**をとります。例えば`width: min(100%, 600px);`とすれば、「常に100%幅だが600pxを超えない」という指定が1行でできます。これにより、画面が広いときは最大600pxの固定幅、狭いときは親幅一杯、といったコンテナを簡潔に記述できます。

- **`max(a, b, ...)`**: 複数値から**最大値**をとります（`min()`の逆）。例えば`height: max(50vh, 300px);`なら「最低でも300px、画面が大きければ50vhまで伸ばす」となります。`min`/`max`ともに、引数はいくつでも可能で、異なる単位の比較も自動で行われます。

- **`clamp(min, preferred, max)`**: **範囲を指定して値をクランプ（挟み込む）**します。3つの引数で最小値・望ましい値・最大値を渡し、ブラウザは計算した望ましい値がその範囲内に収まるよう自動調整します。例えば`font-size: clamp(1rem, 2vw, 2rem);`とすると、画面幅に応じてフォントサイズを2vwで伸縮させつつ、最低1rem、最大2remに制限できます。これにより**メディアクエリ不要**で滑らかにテキストを拡大縮小する**流体タイポグラフィ**が一行で実現できます。

これらの関数は**すべてモダンブラウザでサポート済み**（2020年前後から対応）で、レスポンシブ実装の定番になりつつあります。従来はメディアクエリを複数書いて実現していた「小画面ではX、大画面ではY、中間は逓増」という効果も、今では`clamp()`一発です。

**使用例:**

```css
/* 横幅が親の100%だが、広すぎないよう最大1200pxに制限 */
.container {
  width: min(100%, 1200px);
}

/* カードのマージン: 画面小では8px、大では24pxまで増やす */
.card {
  margin: clamp(8px, 5vw, 24px);
}

/* 流体フォントサイズ: 基本16px、画面幅に応じて最大24pxまで成長 */
h1 {
  font-size: clamp(16px, 4vw, 24px);
}
```

上記のように、`min`/`max`/`clamp`を使うと**メディアクエリの境界点を気にせず**値をコントロールできます。特に`clamp()`は「最小–理想–最大」をまとめて指定できるため、レスポンシブなタイポグラフィ設定に有用です。

### メディアクエリの活用と補完

もちろん従来の`@media`も引き続き重要です。ビューポート全体に関わるスタイル（例えば2カラム→1カラムにレイアウトを変える等）はメディアクエリで定義します。ただメディアクエリもレベル4以降で**新機能**が追加されています。

- **`prefers-color-scheme`**: ユーザーのOS/ブラウザのカラーテーマ（ライト/ダーク）に応じてスタイルを切り替えます。ダークモード対応に必須です。例: `@media (prefers-color-scheme: dark) { ... }`

- **`prefers-reduced-motion`**: 動きの少ない表示を好む設定の場合にアニメーションをOFFにするのに使えます。詳細はアクセシビリティ節で触れますが、`@media (prefers-reduced-motion: reduce)`でモーション削減用のスタイルを当てます。

- **環境メディア特性**: OSのハイコントラストモード検知（`forced-colors`や将来の`prefers-contrast`）など、ユーザー環境への適応クエリも登場しています。アクセシビリティと密接に関連するので、これも後述します。

**Container Queries vs Media Queries:** 使い分けとしては、「コンポーネントごとに最適化すべき事項＝コンテナクエリ」、「全体レイアウトや全ページ共通の切替＝メディアクエリ」と考えるとよいでしょう。両者は競合するものではなく**補完関係**にあります。例えば「3カラム→1カラムにする」は画面幅に依存するのでメディアクエリ、「カードの内部余白を増減」はカードを置くカラム幅に依存するのでコンテナクエリ、といった具合です。

## アクセシビリティを高めるCSS設計

アクセシビリティ（a11y）はフロントエンド開発に不可欠です。CSSにおいても、**ユーザーの状況や好みに応じた表示**を心掛ける必要があります。以下、CSSで考慮すべき主なアクセシビリティ項目をまとめます。

- **フォーカス表示の確保**: キーボードユーザーのために、インタラクティブ要素（リンク、ボタン等）にフォーカスが当たった際は**視覚的なアウトライン**を表示することが重要です。デフォルトではブラウザがアウトラインを描画しますが、カスタムスタイルする場合でも`:focus-visible`擬似クラスを用いて**キーボードフォーカス時のみ**はっきり表示することを推奨します。例:

  ```css
  button:focus-visible {
    outline: 3px solid #00f;
    outline-offset: 2px;
  }
  ```

  逆に、マウスクリックでフォーカスが当たった場合にはアウトラインを表示しない（ブラウザデフォルト挙動）ので、ユーザー体験を損ないません。**決してアウトラインを完全に無効化しない**ことが鉄則です。

- **カラコントラスト**: 前景色と背景色のコントラスト比は十分高く保ち、WCAG基準（通常テキストで4.5:1以上）を満たすようにします。CSS自体でコントラストチェックはできませんが、デザイン段階で配慮し、必要に応じて`color-mix()`等で適切な色合いに調整します（`color-mix()`については後述）。最近のブラウザはDevToolsでコントラスト比を警告してくれるので活用しましょう。

- **レスポンシブなタイポグラフィ**: 高齢者や弱視の方などはブラウザのデフォルトフォントサイズを拡大していることがあります。そのためフォントサイズは相対単位（`rem`や`em`）で指定し、ユーザーの設定に追従するようにします。`min()`や`clamp()`でサイズ調整するときも、絶対値pxではなく`rem`基準にすると良いでしょう。

- **アニメーションの抑制 (`prefers-reduced-motion`)**: 激しい動きやパララックス効果は一部ユーザーに不快感やめまいを生じます。CSSでは`@media (prefers-reduced-motion: reduce)`を用いて、ユーザーが「動きを減らす」設定を有効にしている場合にはアニメーションを停止または簡素化します。例えば：

  ```css
  @media (prefers-reduced-motion: reduce) {
    .carousel img {
      animation: none;
    } /* アニメーション停止 */
  }
  ```

  逆に、特に指定がない場合のみ動きを付けるには`(prefers-reduced-motion: no-preference)`条件を使います。

- **ダークモード対応**: 前述の`prefers-color-scheme`を活用し、ライトモードとダークモードで十分なコントラストが得られる配色を提供します。例えばダークモード時には背景を暗色、テキストを淡色に切り替えるCSSを記述します。併せて、`<meta name="color-scheme" content="light dark">`を指定し、ブラウザやOSのUI要素も適切な色になるようにします。

- **コンテンツ順序とCSSの影響**: CSSで`position:absolute`や`flex`の`order`プロパティ等を使って視覚上の要素順序を変えると、スクリーンリーダーでの読み上げ順序とずれが生じる可能性があります。極力HTMLの論理構造が論理順序どおりになるよう設計し、視覚的な並び替えは慎重に行いましょう。例えば、モバイル版でカードの順序を入れ替える必要がある場合、HTML上もその順序にしてCSSでレイアウトするのが望ましいです。

- **代替テキストや非表示要素**: CSSでテキストを視覚的に隠す（`visibility: hidden`や`display: none`）とスクリーンリーダーにも読まれません。一方、`.sr-only`のように視覚には隠すがスクリーンリーダーには届くスタイル（例えば`position: absolute; clip: rect(0 0 0 0);`等）は、視覚的非表示のラベルなどに使います。ユーティリティファーストCSSでは`.sr-only`クラスがよく提供されていますが、自前でも実装できます。アクセシビリティ目的で要素を隠す際は、その**隠し方が適切か（単なる装飾非表示か、全ユーザーに非表示すべきか）**を検討してください。

このようにCSSでもアクセシビリティを考慮するポイントは多岐にわたります。幸いメディアクエリでユーザー設定を検知する仕組みが揃ってきたので、上手に活用しましょう。また、`:focus-visible`や`prefers-reduced-motion`は**プログレッシブエンハンスメント**として扱い、対応ブラウザでは改善されるが非対応でも大きな問題が起きない書き方（例えばフォーカスは常に表示でも致命的ではない）を心掛けることも大切です。

## CSS変数・カスタムプロパティ活用術

CSSカスタムプロパティ（通称CSS変数）は、モダンCSS設計における**テーマ性**や**再利用性**を飛躍的に高める強力な機能です。プリプロセッサの変数と異なり、カスタムプロパティは**CSSOMの一部として動的に変更可能**で、継承やカスケードも適用されます。ここではCSS変数の基礎と、より進んだ`@property`規則（カスタムプロパティの登録）について解説します。

### CSSカスタムプロパティ (`--*`)

**定義と使用:** CSS変数は、`--変数名: 値;`の形で定義し、`var(--変数名)`で使用します。たとえばテーマカラーを変数化する例:

```css
:root {
  --primary-color: #4a90e2;
  --secondary-color: #d0021b;
}

.button {
  background: var(--primary-color);
  color: white;
}
.button--alt {
  background: var(--secondary-color);
}
```

上記では、`--primary-color`と`--secondary-color`をルート（`:root`）に定義しているため、ページ全体で利用可能です。変数を使うことで、後から値を一箇所変えるだけで関連する全スタイルに反映されます。**共通値の再利用やテーマ切替**に非常に便利です。

**特性:** カスタムプロパティは通常のプロパティと同様に**継承**し、また@media内などでも利用できます。未定義時や無効値の場合に使われる**フォールバック**も指定可能です（`var(--some-color, blue)`のように第2引数にフォールバック値を記述）。CSS変数は**DOMへのアクセスやJavaScriptからの変更**も可能で、動的テーマ変更（ダークモード切替ボタンで`document.documentElement.style.setProperty(...)`する等）に重宝します。

**設計法:** デザインシステムに沿って**色・余白・フォントサイズ等を変数化**し、可能な限りハードコーディング値を減らすのがコツです。例えば「スペースの単位（4px刻み）」や「ブレークポイント幅」なども変数化しておくと、将来の調整が容易になります。また、変数名は長くても意味が伝わるようにつけましょう（例: `--brand-primary`や`--spacing-unit`など）。`--dark-grey-text`や`--dark-background`のように、具体的な色コードより**意味に合わせた名前**にすることでスタイルの意図が明確になります。

### `@property`によるカスタムプロパティの登録

CSS Houdiniの一部として**Properties and Values API**が策定され、CSSでもカスタムプロパティを**型付きで登録**できるようになりました。この機能は2024年頃から各ブラウザで使えるようになっています。`@property`規則を使うと、カスタムプロパティに対し以下を指定可能です:

- **値のシンタックス (`syntax`)**: 例えば`<color>`や`<length>`, `<number>`など、その変数がとり得る値の型を指定できます。
- **既定値 (`initial-value`)**: その変数が未指定の場合に用いるデフォルト値。
- **継承可否 (`inherits`)**: デフォルトは`true`（通常のカスタムプロパティは継承する）が、`false`に設定可能。

この登録を行うことで何が嬉しいかというと、**ブラウザがその変数の性質を理解する**ようになります。一番の利点は**スムースなトランジション・アニメーション**が可能になることです。通常、カスタムプロパティを`transition`してもブラウザは値の中身が不明なため補間できませんが、型が登録されていれば数値や色として補間してくれるのです。

**使用例:** 例えばカスタムプロパティで要素の透明度を制御し、それをアニメーションさせたい場合:

```css
@property --fade-progress {
  syntax: "<number>";
  inherits: false;
  initial-value: 0;
}

.box {
  opacity: var(--fade-progress);
  transition: --fade-progress 1s;
}
.box.fade-in {
  --fade-progress: 1;
}
```

上記では、`--fade-progress`という変数を数値型（0～1の範囲を想定）で登録し、デフォルト0、不継承としています。`.fade-in`クラスを付与すると`--fade-progress`が1に変化し、`transition`により`0 → 1`へ1秒かけて補間されるため、結果として`.box`の`opacity`がフェードインします。型登録がない場合、`transition: opacity 1s;`のように直接プロパティをトランジションさせる必要があり、カスタムプロパティ経由ではできませんでしたが、`@property`によって**カスタムプロパティ自体のトランジション**が可能になっています。

現時点では`@property`は最新ブラウザで動作する**高度な機能**です。対応環境下ではデグレードすることなく無視されるので、上記のようなコードを書いておいて、未対応ブラウザでは単に瞬時に切り替わる（フェードしない）だけ、といったフォールバックで問題ないでしょう。

## モダンなアニメーションとトランジション

CSSによるアニメーションは、ユーザー体験を豊かにする一方で慎重な配慮も必要な機能です。最新のCSSでは、従来の`transition`や`@keyframes`に加え、**スクロール連動アニメーション**など新たな領域が拡張されています。このセクションでは、基本のトランジション/アニメーションのおさらいと、Selectors Level 4やScroll Animations Moduleで追加されたトピックを扱います。

### CSSトランジション & アニメーション基礎

- **トランジション (`transition`)**: 状態変化に応じてプロパティの値を**なめらかに補間**します。例えばボタンのhover時に背景色をふわっと変えたい場合、`.btn { transition: background-color 0.3s ease; }`としておけば、`:hover`で`background-color`が変わる際に0.3秒かけて変化します。**ホバー/フォーカス効果やモーダルの表示/非表示**など、状態変化が明確なものに使うのが基本です。

- **キーフレームアニメーション (`@keyframes` & `animation`)**: 複雑な連続アニメーションに用います。`@keyframes`で**途中経過のスタイル**を定義し、`animation`プロパティで要素に適用します。例えばフェードイン+スライドインするモーダル:

  ```css
  @keyframes slideFadeIn {
    0% {
      opacity: 0;
      transform: translateY(20px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }
  .modal {
    animation: slideFadeIn 0.5s ease-out;
  }
  ```

  こうすると`.modal`が表示された際に下からせり上がってくるような効果になります。キーフレームは`from`/`to`で書くこともできます。**インタラクションのフィードバック**（ボタンを押したとき少し縮む等）や**注意喚起**（エラー時に揺れる等）のアニメーションに有用ですが、多用しすぎると前述のアクセシビリティ観点で問題になるので節度が必要です。

### スクロール連動アニメーション (Scroll-driven Animations)

近年新しく加わったのが、スクロール位置をトリガーとしたアニメーションです。**CSS Scroll-driven Animations**により、JSを使わず**スクロール進行度に応じてアニメーション進行**させることが可能になりました。具体的には、新たな`@scroll-timeline`ルールや`animation-timeline`プロパティ、さらに**View Timeline**という概念が導入されています。

**Scroll vs View Timeline:** スクロール連動タイムラインには2種類あります:

- _スクロール進捗タイムライン_（Scroll Progress Timeline）: 特定のスクロールコンテナ全体のスクロール量（トップからボトムまで）に対して0%～100%を割り当て、その割合でアニメーションを進行させます。ページ全体のスクロールや特定の要素のスクロール領域に基づいて動くアニメーションです。

- _ビュー進捗タイムライン_（View Progress Timeline）: ある要素（「被写体 (subject)」と呼ばれる）の**視認性**に応じて0%～100%を進行させます。被写体要素がスクロールコンテナ内で見え始めた瞬間を0%、完全に通過して見えなくなる所を100%とし、その露出度合いに応じてアニメーションを進めます。要素がビューポート内に入ってくるタイミングでアニメーション開始・終了したい場合に適しています。

2025年現在、このScroll-driven Animationsは一部ブラウザで実装が進んでいる状況です（Chrome系は試験的対応あり）。使用例を簡単に紹介します。

**例: スクロール位置で画像をフェードイン**（概念的な例）

```css
/* スクロールタイムラインの定義: ページ全体(scroll-container)のY軸スクロール */
@scroll-timeline scroll-page {
  source: auto; /* 自動で親スクロール（ページ全体）をソースに */
  orientation: block; /* 縦方向をタイムラインに使用 */
}

/* アニメーションの定義 */
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
.element {
  animation: fadeIn 1s linear 1; /* 1秒のフェードインアニメーション */
  animation-timeline: scroll-page; /* 上で定義したタイムラインで進行 */
  animation-duration: 1; /* 注意: 時間ではなくタイムライン進行の割合(100%)を指す */
}
```

上記は擬似的なコードですが、`.element`が画面をスクロールするとともにフェードインしていきます。より正確には、スクロールタイムライン上で`.element`のアニメーションが**時間ではなく空間に同期**するイメージです。今後、スクロール連動の演出（パララックスや要素の出現アニメ）をCSSのみで記述できる機会が増えていくでしょう。

**View Timelineの例:** ビュータイムラインは特定要素の見え具合に反応するので、例えば

```css
.element {
  view-timeline-name: section-progress;
  /* この要素がビューポートに入ったらprogress計測開始 */
}
@keyframes grow {
  from {
    scale: 0;
  }
  to {
    scale: 1;
  }
}
.child {
  animation: grow 1 1 ease both;
  animation-timeline: section-progress;
}
```

のようにすると、`.element`が見え始めた時から子要素`.child`の`grow`アニメーションが進行します（要素が完全に見切れるまでにscaleが0→1になる）。実際には`@scroll-timeline`や`view-timeline-axis`など詳細指定もありますが、概念として**「スクロール位置＝アニメーションの時間軸」**をCSSで結び付けられるようになったと理解してください。

**注意:** これらscroll-drivenアニメは**実験的**な段階であり、使用時はブラウザの対応状況に注意しましょう。将来的には視差効果や無限スクロール演出などをCSSのみで滑らかに実装できるようになる見込みです。

## 進化したグリッドレイアウト

CSS Grid Layoutは2次元レイアウトを劇的に簡素化しましたが、さらに**「サブグリッド」**機能などで強化されています。ここでは、Grid Level 2で追加された`subgrid`と、視覚的に分かりやすい`grid-template-areas`について解説します。

### サブグリッド (`subgrid`)

**サブグリッド**は、ネストしたグリッドコンテナが**親グリッドのトラック定義を継承**できる機能です。通常、グリッドをネストすると各子グリッドは親から独立した列・行トラックを持ち、親子間で列幅が揃わない問題がありました。`subgrid`を使うと、子グリッドの`grid-template-columns`や`grid-template-rows`に`subgrid`を指定することで、**親グリッドと同じトラック配置**を再利用できます。

**メリット:** 複数のカードレイアウトで高さを揃えたい場合など、各カード内の要素（タイトルや画像など）の位置を行方向に合わせることが容易になります。従来は各カードの高さを合わせるためにスクリプトや不格好なCSSが必要でしたが、subgridなら親グリッドの行高さを子にも適用できるため、異なる高さの内容でも**グリッド線に沿って整列**できます。

**使用例:** 以下に親グリッド・子グリッドでsubgridを用いる例を示します。

```html
<div class="grid">
  <div class="item">
    <h3 class="title">タイトル</h3>
    <img class="thumb" src="..." alt="" />
    <p class="desc">説明文</p>
  </div>
  <!-- ...同様の .item が並ぶ -->
</div>
```

```css
.grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: auto auto; /* 2行: 例えばタイトルと残り */
  gap: 1rem;
}
.item {
  display: grid;
  grid-template-columns: subgrid; /* 親と同じ3列構成を継承 */
  grid-template-rows: subgrid; /* 親と同じ2行構成を継承 */
}
.title {
  grid-column: 1 / span 3; /* タイトルは親グリッドの3列全体にまたがる */
}
.thumb {
  grid-column: 1 / 2; /* 左列に配置 */
  grid-row: 2; /* 2行目（親基準で2行目なのでdescと揃う） */
}
.desc {
  grid-column: 2 / 4; /* 残り2列にまたがる */
  grid-row: 2; /* 2行目に配置（thumbと同じ行） */
}
```

上記では、`.grid`が3列×2行のグリッドを定義し、`.item`内部も`subgrid`指定によって**3列×2行の構造**を引き継いでいます。結果として、各`.item`内の`.thumb`（画像）と`.desc`（テキスト）が親グリッドの行で揃い、カード間で高さが異なっても**行が一直線**になります（例えば全カードでタイトル部分の高さが最大のカードに揃う）。subgridなしでは各カード内で独立計算されバラバラになっていたものが、グリッド全体で統制できるわけです。

**注意点:** `subgrid`はFirefoxが早期に対応し、2023年にはChrome/Edge・Safariにも実装されました。現在は主要ブラウザで利用可能ですが、念のため対応状況を確認しつつ使いましょう。未対応ブラウザでは`subgrid`指定が無視され子グリッドが独自計算になるため、見栄え上大崩れしないレイアウトにしておくと安心です。

### グリッドテンプレートエリア (`grid-template-areas`)

`grid-template-areas`は、グリッド配置を**ASCIIアートのように視覚表現**できるプロパティです。グリッドの各セルに名前を付けてレイアウトを定義できます。複雑なサイトレイアウトを直感的に記述できるため、デザインカンプどおりにコーディングしやすくなります。

**使用例:** 典型的なヘッダー・サイドバー・メイン・フッター構成を`grid-template-areas`で定義してみます。

```html
<div class="layout">
  <header class="hd">ヘッダー</header>
  <nav class="sb">サイドバー</nav>
  <main class="mn">メインコンテンツ</main>
  <footer class="ft">フッター</footer>
</div>
```

```css
.layout {
  display: grid;
  grid-template-columns: 200px 1fr;
  grid-template-rows: auto 1fr auto;
  grid-template-areas:
    "hd  hd"
    "sb  mn"
    "ft  ft";
  gap: 1rem;
}
.hd {
  grid-area: hd;
  background: #ccc;
}
.sb {
  grid-area: sb;
  background: #eef;
}
.mn {
  grid-area: mn;
  background: #eef;
}
.ft {
  grid-area: ft;
  background: #ccc;
}
```

`grid-template-areas`では、**引用符で囲んだ文字列**を行として記述します。上記では3行2列のグリッドを指定し、1行目は`"hd  hd"`（ヘッダーが2列分跨ぐ）、2行目は`"sb  mn"`（左にサイドバー、右にメイン）、3行目は`"ft  ft"`（フッターが2列跨ぐ）としています。各要素には対応する`grid-area`名を割り当て（要素のCSSで`grid-area: hd;`など）、それぞれがテンプレート上の名前付きエリアに収まるようにしました。視覚的にレイアウトがイメージしやすく、HTMLやCSSを読む他の開発者にも優しい書き方です。

**補足:** `grid-template-areas`でピリオド (`.`) を使うと**空セル**を表せます。また、命名したエリアは`grid-area`プロパティ（個々の要素に対して指定）で結び付けます。エリアは必ず長方形である必要があり、不整形に配置するとエラーになります。

この機能自体はGrid初版(2017)からありますが、2025年現在でも**グリッド配置検討時の有力な選択肢**です。特にページ全体レイアウトや広告枠の配置などで重宝します。

---

グリッドレイアウト全般として、CSS Gridの強力な点は**メディアクエリとの親和性**です。同じHTML構造でも`@media`内で`grid-template-areas`や`grid-template-columns`を書き換えれば簡単にレイアウト変更できます。Flexboxでは項目順序の変更が難しいケースでも、Gridならエリア定義を切り替えるだけで可能です。さらに前述のコンテナクエリを組み合わせれば、親コンテナのサイズに応じて`grid-template`を変更することもできます。これらを駆使して、**柔軟かつ保守性の高いレイアウト**を実現しましょう。

## 進化したフレックスボックス

Flexbox（CSS Flexible Box Layout Module）は登場以来、1次元レイアウトの主役として広く使われています。仕様自体は成熟していますが、最近のブラウザ対応状況の改善により**ギャップ（gap）**プロパティがFlexboxでも使えたり、align-contentの誤用が減ったりと、開発体験が向上しています。ここでは**見落としがちなプロパティ**や**2025年ならではのポイント**に絞って整理します。

- **`gap`（および`row-gap`, `column-gap`）**: もともとGrid Layoutで導入されたプロパティですが、Flexboxコンテナにも現在は完全対応しています。flexコンテナにおいて、フレックスアイテム間の**溝（ギャップ）**を簡単に設定可能です。例えば`.flex-container { display: flex; gap: 16px; }`とすれば、子要素間の余白を16px確保できます。従来は子要素に`margin-right`などを個別につけて対応していましたが、`gap`なら**方向を気にせず均等な余白**がつき、かつレスポンシブで折り返した場合も縦横の両方に適用されます。`row-gap`と`column-gap`で縦横別々に指定することも可能です。なお、Flexboxでの`gap`はIEでは非対応ですが、IE自体がレガシーなので問題になるケースは少ないでしょう。

- **`align-content`**: Flexboxには`align-items`（単一行の縦方向揃え）と`align-content`（複数行全体の揃え）の2つがあり、混同されがちです。ポイントは**flex-wrapして複数行になったとき**に`align-content`が効果を発揮することです。例えば、複数行にわたるフレックスコンテナで各行間のスペースを均等にしたい場合、`align-content: space-between;`を指定すると上下の余白配分ができます。単一行の場合、このプロパティは効きません（コンテナの高さがアイテム高さにフィットしてしまうため）。したがって、flexアイテムが折り返すレイアウトでは、垂直方向の配置調整に`align-content`を使うと良いでしょう。

- **`justify-content`**: こちらはFlexboxのメイン軸（通常横方向）における配置制御で、非常によく使われます。`center`, `space-between`, `space-around`など多彩な値があります。特筆すべきはFlexboxでは**子要素間の自動マージン**も強力ということです。例えば、ナビゲーションバーで右側にボタンを寄せたい場合、左側の要素に`margin-left: auto`をつけるだけで残りスペースを全てそのマージンが吸収し、右詰め配置が可能です。Gridと異なりFlexでは1行内なら`justify-content`で概ね事足りますが、要素ごとに細かく制御したい時はこのautoマージン技が役立ちます。

- **そのほか**: `flex-basis`での基本サイズ指定や、`flex-grow`/`flex-shrink`での伸縮比指定など、Flexbox特有のプロパティも改めて設計に組み込むと良いでしょう。例えば「カードを等間隔に並べつつ、余白ができたら中央寄せ」は`justify-content: center;`ではなく各カードに`flex: 1 1 auto;`（必要に応じ伸縮する）を指定して対応する、等々テクニックがあります。ただしこれらはCSS自体の新機能というよりFlexboxの奥義なので、ここでは割愛します。

**まとめると**、Flexboxは2025年現在安定して使えるレイアウト手法であり、特に**1次元の整列やコンポーネント内部の配置**に最適です。GridとFlexboxを比較すると、「大きな枠組みはGridで配置し、中身の横並び配置はFlexで調整」するケースが多いでしょう。Flexboxの更新ポイントとして覚えておくべきは**`gap`の活用**で、これによりかつてのマージンハックをやめ、意図が明確なコードにできます。また、`align-content`/`align-items`の使い分けを正しく理解し、複数行のときは忘れず`align-content`を検討しましょう。

## 最新カラー機能とタイポグラフィ戦略

最後に、**カラーとフォント**に関するモダンCSS機能を見てみましょう。カラーでは新関数`color-mix()`など、タイポグラフィではフォントの非同期ロードを制御する`font-display`や可変フォントの活用がポイントです。

### CSSカラー新機能: `color-mix()` 他

CSS Color Level 5で追加された`color-mix()`関数は、**2つの色を指定割合で混合**した色を得ることができます。デザイナーが行っていた色合成をCSSで動的に実現でき、テーマの明暗バリエーション生成などに有用です。

**`color-mix()`の使い方:**

```css
.element {
  /* 青と緑を半々で混ぜた色を背景に適用 */
  background-color: color-mix(in srgb, blue 50%, green);
}
```

基本構文は`color-mix(in 色空間, 色1 率%, 色2 率%)`で、指定した色空間上で混色します。色空間（`srgb`, `lab`, `lch`, `hsl`など）を変えると混ざり方が変わる点にも注意です（例えば`lab`で混ぜると人間の視覚に忠実な混色になる）。割合指定を省略すると自動的に50%:50%になります。上記例では青と緑の中間色（シアン寄りの色）が得られます。

**用途:** ブランドカラーの濃淡バリエーション作成、前景色と背景色の中間色算出、複数テーマ間での色補間など。例えばダークモード用に「ライトテーマの背景色と黒を20%:80%で混ぜる」ことで一貫性を保った暗色を作る、といった使い方も可能です。JavaScript不要で配色調整できる点が魅力です。

**その他のカラー機能:** `color()`関数による色空間直接指定や、将来的には`color-contrast()`関数（2つの候補色からコントラスト比の高い方を選ぶ）なども検討されています。2025年現在、主要ブラウザで`color-mix()`は広くサポートされています。一方、`color-contrast()`はまだ実装が限定的なので、必要な場合はスクリプトやビルド時ツールで補う必要があるでしょう。

### Webフォントと表示戦略: `@font-face` & `font-display`

ウェブフォントを使う際のCSS設定も重要です。`@font-face`ルールでフォントを宣言し、`font-display`ディスクリプタでそのロード挙動を制御できます。

**`@font-face`基本:**

```css
@font-face {
  font-family: "MyFont";
  src: url("/fonts/MyFont.woff2") format("woff2");
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}
```

上記のようにフォント名・ファイルURL・スタイル/ウエイトを指定します。ここで注目は`font-display: swap;`の指定です。

**`font-display`とは:** ウェブフォントが読み込まれるまでの間、テキストをどのように表示するかを決める設定です。値により以下の挙動となります:

- `block` – **FOIT (Flash of Invisible Text)**: 一定時間フォントがロードされるのを**待ち**、その間テキストを透明に隠します。短時間でロードできれば見た目は綺麗ですが、失敗するとテキストがしばらく消えたままになります。
- `swap` – **FOUT (Flash of Unstyled Text)**: フォントを待たず**即座に代替フォントで表示**し、フォントが届き次第差し替えます。一瞬デザイン意図と異なるフォントが表示されますが、ユーザーは常に内容を読めます。
- `fallback` – 上記中間: 極短時間（100ms程度）だけ隠し、それでもダメなら代替フォント表示に切り替え、その後フォントが来たら短い間だけ差し替えを許可。
- `optional` – `fallback`に似るが、ネットワーク状況によってはフォントを諦めて代替のままにする（ユーザー体験優先）。

現代の推奨は**`swap`**です。ユーザーにコンテンツを即時読ませつつ、フォント準備でき次第スムーズに切り替えるため、多くの場合最適なバランスです。`block`は一昔前はブラウザデフォルトでしたが、テキストが見えないリスクがあり、ユーザー体験的に避けられる傾向です（特にモバイル回線では有害）。`optional`は超低速回線でフォントスキップする場合があるのでブランドフォント必須のサイトでは不向きですが、パフォーマンス優先の場合に検討します。

**可変フォントやフォントロードイベント:** 最近では**可変フォント**（weightやitalic度合いを連続値で変化させられるフォント）も増えています。CSSでは`font-variation-settings`や`@font-face`の`font-stretch`/`font-weight`で範囲指定するなど対応済みです。可変フォント1つで複数スタイルを賄えるため、ページ重量削減に寄与します。さらに、フォントの読み込み完了をJSから検知するFont Loading API（FontFaceSet.readyなど）もありますが、CSSだけで言えば`font-display`に委ねる部分が大きいです。

**フォント関連まとめ:** Webフォントはユーザーにリッチなタイポグラフィを提供する反面、読み込み遅延時の扱いが課題でした。CSSの`font-display`を適切に設定し、可能なら`preload`や`<link rel="preconnect">`等でフォント取得を早めることで、**ユーザーがフォント待ちでストレスを感じない**設計を目指しましょう。なお、システムフォント優先の戦略（いわゆる“system UI font stack”）もパフォーマンスとアクセシビリティの観点から再評価されています。CSSでは`font-family: system-ui, ...;`でOS標準フォントを指定できますので、場面によってはカスタムフォントを使わない選択もあり得ます。

## ブラウザサポートとフォールバック戦略

最後に、ここまで紹介した最新機能を現場で使う際の**ブラウザ互換性**について触れておきます。2025年現在、主要モダンブラウザ（Chrome/Edge, Firefox, Safari）は新仕様追従が早くなっていますが、それでもユーザーの一部には古いバージョンやレガシーブラウザを利用している層がいます。**プログレッシブエンハンスメント**の考え方を持って、新機能を導入しつつ古い環境でも致命的な問題が起きないよう配慮しましょう。

### 機能クエリ (`@supports`) の活用

CSSには`@supports`という**Feature Query（機能問い合わせ）**ルールがあり、指定したCSSプロパティ・値の組がブラウザでサポートされているかを条件分岐できます。これを使えば、新機能に対応している場合だけ特定のスタイルを適用し、未対応なら別のスタイルを適用するといったフォールバックが実現可能です。構文はシンプルで、例えば「変数`--bg`が使えるか？」を検査するには:

```css
@supports (--bg: transparent) {
  .card {
    background: var(--bg);
  }
}
@supports not (--bg: transparent) {
  .card {
    background: transparent; /* 代替の処理 */
  }
}
```

`@supports`には`and`, `or`, `not`キーワードで複数条件を組み合わせることもできます。上記のように**フォールバック用CSSを別途記述**してもよいし、あるいはモダンな手法として`@supports`内で上書きスタイルだけ書いて、外側に古いブラウザ向けスタイルを通常記述する（つまり**フォールバックをデフォルト**にして**改善を@supports内**に書く）と、コードの重複を抑えられます。Feature Queriesは**プログレッシブエンハンスメント実装の要**であり、「新しいものほど内側に書く」というパターンで整理すると管理しやすいでしょう。

### ポリフィルやビルドツール

一部機能は、CSSだけでフォールバックが難しい場合に**ポリフィル**（JSで機能をエミュレートするスクリプト）や**プリプロセッサ/ポストプロセッサ**による事前変換を検討します。例えば:

- CSS NestingはPostCSSのnestingプラグインで展開してしまう（対応ブラウザではネイティブ動作、非対応でも展開後CSSは同じ結果に）。
- Container Queriesは完全なポリフィルは困難ですが、コンテナ幅に応じたクラスをJSで付与するライブラリ（昔で言うElement Queriesのアイデア）を使う手もあります。
- Scroll-driven Animationsは未対応ブラウザではアニメーション自体が効かないため、重要度によってはIntersectionObserverを用いたJS実装に切り替えるか検討する。

とはいえ、近年は「対応していないならその演出はなくてもよい」という割り切りもしやすくなっています。例えば`:has()`で親要素のスタイルを変えている場合、非対応ブラウザではそのスタイル変更が行われなくてもUI全体が崩れないよう設計しておく（多少見た目が劣化するだけにする）などです。

### カナリアテストと情報源

新しいCSSを採用するときは、必ず最新の**Can I use**やMDNの**Browser Compatibility**表を確認しましょう。さらに、Chrome/Firefox/Safariのベータ版やテクニカルプレビューでいち早く挙動を試し、**ベンダー差異**がないか検証することもおすすめします。時折、仕様策定中の差異（例えば初期実装では名前が違った等）が残っている場合があります。また、CSSトリック集サイトやW3Cのワーキングドラフトもウォッチしておくと、実験的機能を使う際のヒントになります。

最後に、**ユーザー層に応じた判断**も大事です。企業向けWebならモダンブラウザ使用率が高く最新CSSを積極利用できるでしょうし、公的サイトで古い端末も多いならより慎重になるでしょう。幸い、本ガイドで紹介した新機能の多くは**既存環境を壊さずに付加価値を提供する**ものです。基本的な土台（HTMLの意味マークアップと基本スタイル）はしっかり整え、その上にモダンCSSのエッセンスを加えることで、全ての利用者に対して最善の体験を届けるのが2025年のCSS開発者に求められる姿勢です。

---

本ガイドの内容を踏まえて、ぜひご自身のプロジェクトでも**最新のPure CSS技術**を取り入れてみてください。CSSは年々進化し続けており、JavaScriptに頼らずとも表現力豊かなUI実装や保守性の高い設計が可能になっています。ブラウザの実装状況を確認しつつ、モダンなシンタックスや機能に慣れていけば、開発効率とユーザー体験の双方で大きなメリットを享受できるでしょう。ぜひ日々のコーディングでこれらテクニックを**実践＆応用**してみてください。

**参考資料:**

- MDN Web Docs – _CSS Nesting_ ([Using CSS nesting - CSS: Cascading Style Sheets | MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_nesting/Using_CSS_nesting#:~:text=The%20CSS%20nesting%20module%20allows,size%20can%20also%20be%20reduced)) ([Using CSS nesting - CSS: Cascading Style Sheets | MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_nesting/Using_CSS_nesting#:~:text=There%20are%20certain%20instances%20where,can%20be%20necessary%20or%20helpful)), _:has()_, _:where()_, _Cascade Layers_, _Container Queries_, _min()/max()/clamp()_, _prefers-reduced-motion_, _CSS Custom Properties_, _CSS Properties and Values API (registerProperty)_, _Scroll-driven Animations_, _Subgrid_, _grid-template-areas_, _Flexbox aligning_, _gap in flexbox_, _color-mix()_, _font-display_, _Feature Queries_.
- その他: CSS Tricks, Smashing Magazine, web.dev などの記事や各種ブログ・仕様書ドラフト。
